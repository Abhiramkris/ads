import matplotlib.pyplot as plt

# Define clipping window boundaries
xmin, xmax = 50, 80
ymin, ymax = 10, 40

# Define region codes
INSIDE = 0  # 0000
LEFT = 1    # 0001
RIGHT = 2   # 0010
BOTTOM = 4  # 0100
TOP = 8     # 1000

# Compute region code for a point (x, y)
def compute_outcode(x, y):
    code = INSIDE
    if x < xmin:      # to the left of clip window
        code |= LEFT
    elif x > xmax:    # to the right of clip window
        code |= RIGHT
    if y < ymin:      # below the clip window
        code |= BOTTOM
    elif y > ymax:    # above the clip window
        code |= TOP
    return code

# Cohen-Sutherland clipping algorithm
def cohen_sutherland_line_clip(x0, y0, x1, y1):
    outcode0 = compute_outcode(x0, y0)
    outcode1 = compute_outcode(x1, y1)
    accept = False

    while True:
        if not (outcode0 | outcode1):  # Both endpoints inside
            accept = True
            break
        elif outcode0 & outcode1:  # Both endpoints share an outside zone
            break
        else:
            # One endpoint is outside the clip window
            outcode_out = outcode1 if outcode1 > outcode0 else outcode0

            if outcode_out & TOP:  # Point is above the clip window
                x = x0 + (x1 - x0) * (ymax - y0) / (y1 - y0)
                y = ymax
            elif outcode_out & BOTTOM:  # Point is below the clip window
                x = x0 + (x1 - x0) * (ymin - y0) / (y1 - y0)
                y = ymin
            elif outcode_out & RIGHT:  # Point is to the right of the clip window
                y = y0 + (y1 - y0) * (xmax - x0) / (x1 - x0)
                x = xmax
            elif outcode_out & LEFT:  # Point is to the left of the clip window
                y = y0 + (y1 - y0) * (xmin - x0) / (x1 - x0)
                x = xmin

            if outcode_out == outcode0:
                x0, y0 = x, y
                outcode0 = compute_outcode(x0, y0)
            else:
                x1, y1 = x, y
                outcode1 = compute_outcode(x1, y1)

    return accept, x0, y0, x1, y1

# Define line segment endpoints
x0, y0 = 70, 20
x1, y1 = 100, 10

# Clip the line segment
accept, x0_clip, y0_clip, x1_clip, y1_clip = cohen_sutherland_line_clip(x0, y0, x1, y1)

# Plot the clipping window
plt.plot([xmin, xmax, xmax, xmin, xmin], [ymin, ymin, ymax, ymax, ymin], color='black')

# Plot the original line segment
plt.plot([x0, x1], [y0, y1], color='blue', label='Original Line')

# Plot the clipped line segment
if accept:
    plt.plot([x0_clip, x1_clip], [y0_clip, y1_clip], color='green', label='Clipped Line')
else:
    plt.text((x0 + x1) / 2, (y0 + y1) / 2, 'Line Rejected', color='red', fontsize=12)

# Final plot settings
plt.gca().set_aspect('equal', adjustable='box')
plt.title('Cohen-Sutherland Line Clipping')
plt.xlabel('X')
plt.ylabel('Y')
plt.legend()
plt.grid(True)
plt.show()



#ball


import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

# Set up the figure and axis
fig, ax = plt.subplots()
ax.set_xlim(0, 10)  # Horizontal axis limit
ax.set_ylim(0, 10)  # Vertical axis limit

# Ellipse properties
ellipse_radius = 0.5
ball_x = 0.5  # Initial horizontal position
ball_y = 0.5  # Initial vertical position
ball_speed_x = 0.05  # Horizontal speed
ball_speed_y = 0.05  # Vertical speed
ball_max_height = 9.5  # Max height for bouncing
ball_min_height = 0.5  # Min height for bouncing

# Create a circle object (ellipse)
ellipse = plt.Circle((ball_x, ball_y), radius=ellipse_radius, color='red')

# Add the ellipse to the plot
ax.add_patch(ellipse)

# Function to update the animation in each frame
def update(frame):
    global ball_x, ball_y, ball_speed_x, ball_speed_y
    # Update horizontal position
    ball_x += ball_speed_x
    if ball_x > 9.5 or ball_x < 0.5:  # Reverse direction if it hits left or right limits
        ball_speed_x = -ball_speed_x
    # Update vertical position (bouncing)
    ball_y += ball_speed_y
    if ball_y > ball_max_height or ball_y < ball_min_height:  # Reverse direction when hitting top or bottom
        ball_speed_y = -ball_speed_y
    # Update ellipse position
    ellipse.set_center((ball_x, ball_y))
    return ellipse,

# Create animation object using FuncAnimation
ani = FuncAnimation(fig, update, frames=np.arange(0, 1000), interval=20, blit=True)

# Display the animation
plt.show()




#experiment 1 

import matplotlib.pyplot as plt 
def DDA(x1,x2,y1,y2):
    xc=[x1]
    yc=[y1]
    dx=x2-x1
    dy=y2-y1
    if (abs(dx)>abs(dy)):
        steps=abs(dx)
    else:
        steps=abs(dy)
        Xinc=float(dx/steps)
        Yinc=float(dy/steps)
        for i in range(steps):
            x1=float(x1+Xinc)
            y1=float(y1+Yinc)
    xc.append(x1)
    yc.append(y1)
    plt.plot(xc,yc)
plt.xlabel("x-axis")
plt.ylabel("y-axis")
plt.title("DDA LINE DRAWING")

DDA(5,7,10,15)      
plt.show()



#Experiment 2

import matplotlib.pyplot as plt

# Bresenham's Line Drawing Algorithm
def bresenhams(x1, y1, x2, y2):
    xc = [x1]
    yc = [y1]

    dx = abs(x2 - x1)
    dy = abs(y2 - y1)

    # Determine the direction of the steps
    sx = 1 if x2 > x1 else -1
    sy = 1 if y2 > y1 else -1

    if dx > dy:
        p = 2 * dy - dx
        while x1 != x2:
            x1 += sx
            if p >= 0:
                y1 += sy
                p -= 2 * dx
            p += 2 * dy
            xc.append(x1)
            yc.append(y1)
    else:
        p = 2 * dx - dy
        while y1 != y2:
            y1 += sy
            if p >= 0:
                x1 += sx
                p -= 2 * dy
            p += 2 * dx
            xc.append(x1)
            yc.append(y1)

    # Plot the line
    plt.plot(xc, yc, marker='o', color='blue')
    plt.xlabel("x-axis")
    plt.ylabel("y-axis")
    plt.title("Bresenham's Line Drawing Algorithm")
    plt.grid(True)
    plt.show()

# Get user input for the coordinates
print("Enter the first and end coordinates")
x1 = int(input("Enter x1: "))
y1 = int(input("Enter y1: "))
x2 = int(input("Enter x2: "))
y2 = int(input("Enter y2: "))

# Call the function to draw the line
bresenhams(x1, y1, x2, y2)






